<!DOCTYPE html>
<html>
	<head><meta charset="UTF-8"/><title>Cellular Automata</title></head>
	<style>
	.code {
		font-family: Courier New, Courier, Lucida Sans Typewriter, Lucida Typewriter, monospace;
		width: 96%;
		padding: 10px;
	}
	.positioned {
		display: inline-block;
		position: absolute;
		width: 45%;
	}
	.dotted {
		border-style: dotted;
		padding: 10px;
	}
	h2 {
		display: inline-block;
	}
	#settings {
		margin-left: 50%;
		margin-top: 0%;
		float: right;
	}
	</style>
	<body>
		<div class = "positioned">
			<h1 id = "title">Mekal Covic's Cellular Automata Simulator</h1>

			<div class = "dotted">
				<h2>Iteration Function</h2>&emsp;<button onclick = "next()">+</button>
				<div id = "list">
				</div>
			</div>
			<canvas width="400" height = "400" style="display: None;" id = "game"></canvas><br/>
			<button onclick = "start(this)">Next</button>
			<h1 id = "pause" style = "display:None;">Paused!</h1>
		</div>
		<div class = "positioned" id = "settings">
			<h1>&emsp;</h1>
			<div class = "dotted">
				<h2>Display Settings</h2><br/>
				<input type="radio" name="display" onclick="displayMode(0)" id = "checkme">Greyscale</input><br/>
				<input type="radio" name="display" onclick="displayMode(1)">Hue</input><br/>
				<input type="radio" name="display" onclick="displayMode(2)">Hue (with input min = black)</input>
				<br/><br/>
				<input id = "min" placeholder = "Override Input Mininum (default:0)" style = "width: 40%"></input><br/>
				<input id = "max" placeholder = "Override Input Maxinum (default:1)" style = "width: 40%"></input>
				<br/><br/>
				<input id = "highRes" type = "checkbox">High Resolution</input>
			</div>
		</div>
		<script>
			var size;
			var len;
			
			function setSize(resolution) {
				size = resolution;
				len = 400 / size;
			}

			var grid = [];
			const game = document.getElementById("game");
			var ctx;
			var mode = 0;
			var nextObj;
			var pause = false;
			var colourDisplay = 0;
			var min = 0;
			var max = 1;
			
			function handleKey(e) { // check if enter is pressed
				if (e.keyCode == 13) {
					next();
				}
			}

			function displayMode(mode) {
				colourDisplay = mode;
			}
			
			function next() {
				// This function just adds another line to the list
				
				let inputs = document.getElementById("list");
				let node = inputs.appendChild(document.createElement("input"));
				node.classList.add("code");
				node.addEventListener('keypress', handleKey);
				node.addEventListener('paste', function(e) { // This paste code overrides the paste functionality with newlines to put them in new input lines
					let text = e.clipboardData.getData('text');
					
					if (/\n/.test(text)) {
						e.preventDefault();
						e.stopPropagation();

						let pastedText = text.split("\n");
						node.value = pastedText[0];
						
						for (let i = 1; i < pastedText.length; ++i) {
							next().value = pastedText[i];
						}
					}
				});
				
				inputs.appendChild(document.createElement("br"));
				return node;
			}
			
			function render() {
				for (let x = 0; x < size; ++x) {
					for (let y = 0; y < size; ++y) {
						let gridVal = grid[x][y]; // the value
						let intensity = (gridVal - min) * 255 / (max - min);
						if (colourDisplay == 0) {
							ctx.fillStyle = "rgba(" + intensity + "," + intensity + "," + intensity + ",255)";
						} else if (colourDisplay == 2 && intensity == 0) {
							ctx.fillStyle = "black";
						} else {
							ctx.fillStyle = "hsl(" + intensity + ", 100%, 50%)";
						}
						ctx.fillRect(x * len, y * len, (x + 1) * len, (y + 1) * len);
					}
				}
			}

			document.addEventListener('keydown', function(e) {
				if (mode == 2 && e.keyCode == 32) {
					document.getElementById("pause").style = (pause = !pause) ? "" : "display:None;";
				}
			});
			
			function transpile(str, isBoolean) {
				if (str.trim() == "") {
					return "";
				}

				if (isBoolean) {
					str = str.replaceAll(/=/g, "==");
					str = str.replaceAll(/ and /g, " && ");
					str = str.replaceAll(/ or /g, " || ");
					str = str.replaceAll(/ not /g, " ! ");
					return replaceExpressions(str);
				} else if (/.+ where .+/.test(str)) {
					let parts = str.split(/ where /);
					return "if(" + transpile(parts[1], true) + "){" + transpile(parts[0], false) + ";}";
				} else if (/.+=.+/.test(str)) {
					return replaceExpressions(str);
				} else {
					return "return " + replaceExpressions(str);
				}
			}

			function replaceExpressions(str) {
				str = str.replaceAll(/sin\(/g, "Math.sin(");
				str = str.replaceAll(/cos\(/g, "Math.cos(");
				str = str.replaceAll(/tan\(/g, "Math.tan(");
				
				str = str.replaceAll(/floor\(/g, "Math.floor(");
				str = str.replaceAll(/ceil\(/g, "Math.ceil(");
				
				str = str.replaceAll(/\^/g, "**");
				return str;
			}
			
			function start(bn) {
				if (mode == 1) {
					mode = 2;
					bn.remove();
					
					setInterval(function() {
						if (!pause) {
							let nextGrid = [];
							
							for (let x = 0; x < size; ++x) {
								nextGrid[x] = [];
								let prev = 0;
								let current = grid[x][0];
								
								let prevEast = 0;
								let currentEast = x == size - 1 ? 0 : grid[x + 1][0];
								
								let prevWest = 0;
								let currentWest = x == 0 ? 0 : grid[x - 1][0];
								
								for (let y = 0; y < size; ++y) {
									// because I didn't feel like grabbing from an array 9 times per square
									let next = 0;
									let nextEast = 0;
									let nextWest = 0;

									if (y < size - 1) {
										next = grid[x][y + 1];
										nextEast = x == size - 1 ? 0 : grid[x + 1][y + 1];
										nextWest = x == 0 ? 0 : grid[x - 1][y + 1];
									}

									nextGrid[x][y] = nextObj(prevWest, prev, prevEast, currentWest, current, currentEast, nextWest, next, nextEast);
									
									prev = current;
									prevEast = currentEast;
									prevWest = currentWest;
									
									current = next;
									currentEast = nextEast;
									currentWest = nextWest;
								}
							}
							
							grid = nextGrid;
							
							render();
						}
					}, 250);
				} else {
					mode = 1;
					bn.innerHTML = "Start";

					setSize(document.getElementById("highRes").checked ? 40 : 20);

					fn = "nextObj = function(NW, N, NE, W, C, E, SW, S, SE) {";
					
					let inputDiv = document.getElementById("list");
					let inputs = inputDiv.children;
					
					for (let i = 0; i < inputs.length; i += 2) {
						fn += transpile(inputs[i].value, false) + ";";
					}
					
					fn += "}";
					console.log(fn);
					// haha yes
					// there's no server so shouldn't have xss
					eval(fn);
					
					// hide dotted elements
					let divs = document.getElementsByClassName("dotted");
					
					for (let i = 0; i < divs.length; ++i) {
						divs[i].style = "display: None;";
					}
					
					// And now we check if max and min are overidden and if so address it
					let maxEl = document.getElementById("max");
					let minEl = document.getElementById("min");
					
					if (maxEl.value != "" || /\s+/.test(maxEl.value)) {
						max = parseFloat(maxEl.value);
					}
					
					if (minEl.value != "" || /\s+/.test(minEl.value)) {
						min = parseFloat(minEl.value);
					}
					
					// set up canvas
					game.style = "border:1px solid #000000;";
					
					ctx = game.getContext("2d");
					
					for (let x = 0; x < size; ++x) {
						let row = grid[x] = [];
						
						for (let y = 0; y < size; ++y) {
							row[y] = 0;
						}
					}
					
					render();

					// Move on to initial construction
					
					game.addEventListener('mousedown', function(e) {
						let pos = getCursorPos(e);
						let gx = Math.floor(pos[0]/len); // grid x
						let gy = Math.floor(pos[1]/len); // grid y
						grid[gx][gy] = grid[gx][gy] == 0 ? 1 : 0;
						render();
					});
				}
			}
			
			// this is cursed
			function getCursorPos(evnt) {
				let rect = game.getBoundingClientRect();
				let x = evnt.clientX - rect.left;
				let y = evnt.clientY - rect.top;
				return [x, y];
			}
			
			document.getElementById("checkme").checked = true;
		</script>
	</body>
</html>